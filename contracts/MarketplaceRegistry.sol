pragma solidity ^0.5.11;
pragma experimental ABIEncoderV2;


import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";

import "@openzeppelin/contracts/math/SafeMath.sol";
import "@openzeppelin/contracts/ownership/Ownable.sol";

// Storage
import "./storage/McStorage.sol";
import "./storage/McConstants.sol";

// DAI
import "./DAI/dai.sol";

// idle.finance
import "./idle-contracts/contracts/IdleToken.sol";



/***
 * @notice - This contract is that ...
 **/
contract MarketplaceRegistry is Ownable, McStorage, McConstants {
    using SafeMath for uint;

    address IDLE_TOKEN_ADDRESS;
    address underlyingERC20;

    Dai public dai;  //@dev - dai.sol
    IERC20 public erc20;
    IdleToken public idleToken;

    constructor(address _erc20, address _idleToken) public {
        dai = Dai(_erc20);
        erc20 = IERC20(_erc20);
        idleToken = IdleToken(_idleToken);

        IDLE_TOKEN_ADDRESS = _idleToken;
        underlyingERC20 = _erc20;
    }


    /***
     * @dev - Stakeholder of Social Impact Bond
     * Service Provider - Institution for developing vaccines of COVID19
     * Investor
     * Evaluator
     * Government
     **/


    /***
     * @dev - Register functions
     **/
    function registerInvester() public returns (bool) {}
     
    function registerServiceProvider() public returns (bool) {}

    function registerEvaluator() public returns (bool) {}

    function registerGovernment() public returns (bool) {}



    /***
     * @dev - Define Objective for saving cost (This objective become criteria for whether it judging success or not)
     *      - This function is executed by government only.
     **/
    function defineObjective(uint _serviceProviderId, uint _savedCostOfObjective) public returns (bool) {
        Objective storage objective = objectives[_serviceProviderId];
        objective.serviceProviderId = _serviceProviderId;
        objective.savedCostOfObjective = _savedCostOfObjective;

        emit DefineObjective(objective.serviceProviderId, objective.savedCostOfObjective);
    }

    /***
     * @dev - Evaluate outcome which is generated by service provider
     *      - The outcome is evaluated by evaluator
     **/
    function evaluateOutcome(uint _serviceProviderId, uint _evaluatorId, uint _savedCostOfOutcome) public returns (bool) {
        uint _savedCostOfObjective = getObjective(_serviceProviderId).savedCostOfObjective;

        Objective storage objective = objectives[_serviceProviderId];
        objective.evaluatorId = _evaluatorId;
        objective.savedCostOfOutcome = _savedCostOfOutcome;
        objective.isEvaluated = true;

        //@dev - Conditional branch whether objective is achieved or not
        if (objective.savedCostOfOutcome >= _savedCostOfObjective) {
            objective.isAchieved = true;
        }

        emit EvaluateOutcome(objective.serviceProviderId, 
                             objective.evaluatorId, 
                             objective.savedCostOfOutcome, 
                             objective.isEvaluated,
                             objective.isAchieved);        
    } 


    /***
     * @dev - Collect fund with DAI.
     **/
    //function collectFund(uint _serviceProviderId , uint _investorId) public returns (bool) {}



    /***
     * @dev - Lend pooled fund(DAI) to idle.finance(idleDAI)
     **/
    function lendPooledFund(uint256 _mintAmount, uint256[] memory _clientProtocolAmounts) public returns (bool) {
        // In progress
        dai.approve(IDLE_TOKEN_ADDRESS, _mintAmount);
        idleToken.mintIdleToken(_mintAmount, _clientProtocolAmounts);
    }
    
    /***
     * @dev - Redeem pooled fund(DAI) from idle.finance(idleDAI)
     **/
    function redeemPooledFund() public returns (bool) {}

    /***
     * @dev - Withdraw pooled fund(DAI) and distribute seed money plus interest to each investors
     **/
    function withdrawAndDistributePooledFund() public returns (bool) {

    }




    /***
     * @dev - Getter function
     **/
    function getObjective(uint _serviceProviderId) public view returns (Objective memory) {
        Objective memory objective = objectives[_serviceProviderId];
        return objective;
    }
    












    /***
     * @dev - Testing functions
     **/
    function testFunc(uint256 _mintAmount) public returns (bool, uint256 _approvedValue) {
        uint256 _id = 1;
        uint256 _exchangeRateCurrent = McConstants.onePercent;

        address _to = 0x8Fc9d07b1B9542A71C4ba1702Cd230E160af6EB3;

        address _owner = address(this); //@dev - contract address which do delegate call
        //address _owner = msg.sender;
        address _spender = underlyingERC20;    // DAI address on Kovan

        //@dev - Allow _spender to withdraw from your account, multiple times, up to the _value amount. 
        erc20.approve(_spender, _mintAmount.mul(10**18));
            
        //@dev - Returns the amount which _spender is still allowed to withdraw from _owner
        uint256 _approvedValue = erc20.allowance(_owner, _spender);
        
        //@dev - Expected transferred value is 1.05 DAI（= 1050000000000000000 Wei）
        erc20.transfer(_to, _mintAmount.mul(10**18).div(10**2));        

        emit Example(_id, _exchangeRateCurrent, msg.sender, _approvedValue);

        return (McConstants.CONFIRMED, _approvedValue);
    }

    function balanceOfCurrentAccount(address _currentAccount) public view returns (uint256 balanceOfCurrentAccount) {
        return erc20.balanceOf(_currentAccount);
    }
    

    function transferDAIFromUserToContract(uint256 _mintAmount) public returns (bool) {
        address _from = address(this);
        address _to = 0x8Fc9d07b1B9542A71C4ba1702Cd230E160af6EB3;

        erc20.approve(underlyingERC20, _mintAmount.mul(10**18));
        uint256 _allowanceAmount = erc20.allowance(address(this), underlyingERC20);
        //uint256 _allowanceAmount = erc20.allowance(msg.sender, address(this));
        erc20.transferFrom(_from, _to, _mintAmount.mul(10**18).div(10**2));

        emit _TransferFrom(_from, _to, _mintAmount.mul(10**18), _allowanceAmount);
    }
    
}
